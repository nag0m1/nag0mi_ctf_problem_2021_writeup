# nag0m1CTF

https://nag0mictf.tk

## malware

### Ransomware

> Attention! Your flag file is encrypted! If you want to see the file, you have to decrypt it. Good luck and enjoy this problem!

この問題は，ランサムウェアの被害にあいファイルが暗号化されてしまったことを想定した問題となっています．

<br>

さまざまなランサムウェアの特徴があるため一概にこれがすべてとは言えませんが，ファイル自体が暗号化されて拡張子が変更されるというケースも少なくありません．

大抵のファイル暗号化に使用されるアルゴリズムはAESであるため，今回の問題ではAESを採用しています．

<br>

```
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.Util.number import * 
import sys

seed = sys.argv[1][0].encode()

def m_seq(seed):
    out = []
    for i in range(2 ** 7):
        bit = (seed >> 6) & 0x01
        if (bit == 1):
            seed = (seed << 1) ^ 0b11100011
        else:
            seed = (seed << 1)
        out.append(str(bit))
    out = long_to_bytes(int("".join(out), 2))
    return out

def encrypt(pt, key):
    plain = AES.new(key, AES.MODE_CTR, counter=Counter.new(128))
    ct = plain.encrypt(pt)
    return ct

def read():
    with open(sys.argv[1], "rb") as f:
        pt = f.read()
    return pt

def write(ct):
    with open(sys.argv[1] + ".hogehoge", "wb") as fw:
        fw.write(ct)

def main():
    key = m_seq(bytes_to_long(seed))
    pt = read()
    ct = encrypt(pt, key)
    write(ct)

if __name__ == "__main__":
    main()
```

<br>

このプログラムを用いて暗号化したようです．

`seed`を`m_seq`に入れて出力したものを`key`に格納して，AES-CTRモードで暗号化しているということがわかります．

AES-CTRの`counter`は細工がないので，`key`の値さえわかれば解けそうです．

<br>

ここで，`m-seq`はM系列の乱数生成回路となっています．

ここで乱数を生成していますが，ここでの目的は`seed`の値を長周期の乱数にすることを目的としているので，ここの中身に意味はありません．

乱数生成回路は`seed`が等しかった場合，つねに同じ乱数値を生成します．したがって，`seed`値がわかれば`key`を求められます．

<br>

長くなりましたが，この問題は`seed`がわかれば`key`を特定することができ，この値を用いて復号すれば求められます．

ここで重要になるのが以下の式です．

```
seed = sys.argv[1][0].encode()
```

ここで，`sys.argv[1]`というものが出てきています．

これは，このプログラムを実行するにあたって，入力された値を持ってくる意味があります．

そのため，以下の式があった場合，

```
> python3 malware.py test.txt 
```

`sys.argv[1]`には`"test.txt"`という文字列が入ります．

この文字列に対して，`sys.argv[1][0]`となっているため，ここには`'t'`が含まれます．

この文字を`seed`として鍵が生成されています．

<br>

現時点では，ファイルを暗号化されたときに`sys.argv[1]`に何が入っていたかがわかりません．

これを知るヒントが，プログラムの`write()`の箇所にあります．

```
def write(ct):
    with open(sys.argv[1] + ".hogehoge", "wb") as fw:
        fw.write(ct)
```

この文より，元のファイル名に`.hogehoge`を付けたものが暗号化ファイルになっていることがわかります．

したがって，暗号化されたファイル名が`get_flag.png.hogehoge`となっているため，元のファイル名は`get_flag.png`であることがわかります．

したがって，`seed`には`'g'`が入っていることがわかりました．

<br>

あとは，これを参考に復号したら`flag`を入手することができます．

```
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.Util.number import * 
import os
import sys
import base64

seed = sys.argv[1][0].encode()
# seed = b"g"

def lfsr(seed):
    out = []
    for i in range(2 ** 7):
        bit = (seed >> 6) & 0x01
        if (bit == 1):
            seed = (seed << 1) ^ 0b11100011
        else:
            seed = (seed << 1)
        out.append(str(bit))
    out= "".join(out)
    out = int(out, 2)
    out = long_to_bytes(out)
    return out

def decrypt(ct, key):
    cipher = AES.new(key, AES.MODE_CTR, counter=Counter.new(128))
    dt = cipher.decrypt(ct)
    return dt

def read():
    with open(sys.argv[1], "rb") as f:
        pt = f.read()
    return pt

def write(ct):
    with open(sys.argv[1].replace(".hogehoge", ""), "wb") as fw:
        fw.write(ct)

def main():
    key = lfsr(bytes_to_long(seed))
    ct = read()
    pt = decrypt(ct, key)
    write(pt)

if __name__ == "__main__":
    main()

```
<br>

`flag{1_m4ke_ae5_ma1war3}`

<br>

---

**注意**

このプログラムは，マルウェアに感染したとしても暗号化されたファイルは復号することが可能であるということを理解していただくために作成しています．
このプログラムを決して悪用しないようお願いします．

---